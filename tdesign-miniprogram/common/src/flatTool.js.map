{"version":3,"sources":["../src/common/src/flatTool.ts"],"names":[],"mappings":"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","file":"flatTool.js","sourcesContent":["/** ****************************************************************\n MIT License https://github.com/qiu8310/minapp/blob/v1.0.0-alpha.1/packages/minapp-core/src/system/util/object.ts\n Author Mora <qiuzhongleiabc@126.com> (https://github.com/qiu8310)\n****************************************************************** */\n\nexport const getPrototypeOf = function (obj: any): any {\n  return Object.getPrototypeOf ? Object.getPrototypeOf(obj) : obj.__proto__;\n};\n\n/**\n * 判断 something 是不是一个 JS Object (从 mora-script 中取过来的)\n *\n * 除了 null, 及字面量，其它一般都是 Object，包括 函数\n */\nexport const isObject = function isObject(something: any) {\n  const type = typeof something;\n  return something !== null && (type === 'function' || type === 'object');\n};\n\n/**\n * 遍历继承关系类的 prototype\n *\n * @export\n * @param {Function} callback - 回调函数，函数参数是遍历的每个实例的 prototype，函数如果返回 false，会终止遍历\n * @param {any} fromCtor  - 要遍历的起始 class 或 prototype\n * @param {any} toCtor    - 要遍历的结束 class 或 prototype\n * @param {boolean} [includeToCtor=true] - 是否要包含结束 toCtor 本身\n *\n * @example\n * A -> B -> C\n *\n * 在 C 中调用： iterateInheritedPrototype(fn, A, C, true)\n * 则，fn 会被调用三次，分别是 fn(A.prototype) fn(B.prototype) fn(C.prototype)\n */\nexport const iterateInheritedPrototype = function iterateInheritedPrototype(\n  callback: (proto: Record<string, any>) => boolean | void,\n  fromCtor: any,\n  toCtor: any,\n  includeToCtor = true,\n) {\n  let proto = fromCtor.prototype || fromCtor;\n  const toProto = toCtor.prototype || toCtor;\n\n  while (proto) {\n    if (!includeToCtor && proto === toProto) break;\n    if (callback(proto) === false) break;\n    if (proto === toProto) break;\n    proto = getPrototypeOf(proto);\n  }\n};\n\nexport interface ClassInstanceToObjectOptions {\n  /**\n   * 将所有的对象中的函数绑定到指定的对象上\n   *\n   * **注意：对象中的箭头函数无法重新绑定**\n   */\n  bindTo?: any;\n\n  /**\n   * 要排除的键名\n   *\n   * 默认： ['constructor']\n   */\n  excludes?: string[];\n\n  /**\n   * 递归遍历到的终点对象或class(不会遍历终点对象上的属性)\n   *\n   * 默认： Object\n   */\n  till?: any;\n\n  /**\n   * 生成的新对象的键值是否需要 enumerable， 0 表示使用原本的配置，此值默认为 true\n   */\n  enumerable?: 0 | boolean;\n  /**\n   * 生成的新对象的键值是否需要 configurable， 不指定或指定 0 则使用原本的\n   */\n  configurable?: 0 | boolean;\n  /**\n   * 生成的新对象的键值是否需要 writable，不指定或指定 0 则使用原本的\n   */\n  writable?: 0 | boolean;\n}\n\n/**\n *\n * 将一个可能包含原型链的对象扁平化成单个对象\n *\n * 如，现有这样的类的继承关系 A -> B -> C，当创建一个实例 a = new A() 时\n *\n * a 实例会存有 B、C 的原型链，使用此函数 newa = toObject(a) 之后，\n * newa 就会变成一个 PlainObject，但它有 A、B、C 上的所有属性和方法，\n * 当然不包括静态属性或方法\n *\n * 注意1：用此方法的话，尽量避免在类中使用胖函数，胖函数的 this 死死的绑定\n * 在原对象中，无法重新绑定\n *\n * 注意2：类继承的时候不要在函数中调用 super，toObject 之后是扁平的，没有 super 之说\n */\nexport const toObject = function toObject(\n  something: any,\n  options: ClassInstanceToObjectOptions = {},\n): { [key: string]: any } {\n  const obj = {};\n  if (!isObject(something)) return obj;\n\n  const excludes = options.excludes || ['constructor'];\n  const { enumerable = true, configurable = 0, writable = 0 } = options;\n  const defaultDesc: PropertyDescriptor = {};\n  if (enumerable !== 0) defaultDesc.enumerable = enumerable;\n  if (configurable !== 0) defaultDesc.configurable = configurable;\n  if (writable !== 0) defaultDesc.writable = writable;\n\n  iterateInheritedPrototype(\n    (proto) => {\n      Object.getOwnPropertyNames(proto).forEach((key) => {\n        if (excludes.indexOf(key) >= 0) return;\n        if (Object.prototype.hasOwnProperty.call(obj, key)) return;\n        const desc = Object.getOwnPropertyDescriptor(proto, key) as PropertyDescriptor;\n\n        const fnKeys = ['get', 'set', 'value'] as 'get'[];\n        fnKeys.forEach((k) => {\n          if (typeof desc[k] === 'function') {\n            const oldFn = desc[k] as any;\n            desc[k] = function (...args: any[]) {\n              return oldFn.apply(\n                Object.prototype.hasOwnProperty.call(options, 'bindTo') ? options.bindTo : this,\n                args,\n              );\n            };\n          }\n        });\n        Object.defineProperty(obj, key, { ...desc, ...defaultDesc });\n      });\n    },\n    something,\n    options.till || Object,\n    false,\n  );\n\n  return obj;\n};\n\nexport const isPlainObject = function isPlainObject(something: any) {\n  return Object.prototype.toString.call(something) === '[object Object]';\n};\n"]}