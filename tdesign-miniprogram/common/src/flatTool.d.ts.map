{"version":3,"sources":["../src/common/src/flatTool.ts"],"names":[],"mappings":"AAAA;;;qEAGqE;AAErE,eAAO,MAAM,cAAc,QAAkB,GAAG,KAAG,GAElD,CAAC;AAEF;;;;GAIG;AACH,eAAO,MAAM,QAAQ,cAAgC,GAAG,YAGvD,CAAC;AAEF;;;;;;;;;;;;;;GAcG;AACH,eAAO,MAAM,yBAAyB,qBAClB,OAAO,MAAM,EAAE,GAAG,CAAC,KAAK,OAAO,GAAG,IAAI,YAC9C,GAAG,UACL,GAAG,kCAYZ,CAAC;AAEF,MAAM,WAAW,4BAA4B;IAC3C;;;;OAIG;IACH,MAAM,CAAC,EAAE,GAAG,CAAC;IAEb;;;;OAIG;IACH,QAAQ,CAAC,EAAE,MAAM,EAAE,CAAC;IAEpB;;;;OAIG;IACH,IAAI,CAAC,EAAE,GAAG,CAAC;IAEX;;OAEG;IACH,UAAU,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC;IACzB;;OAEG;IACH,YAAY,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC;IAC3B;;OAEG;IACH,QAAQ,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC;CACxB;AAED;;;;;;;;;;;;;;GAcG;AACH,eAAO,MAAM,QAAQ,cACR,GAAG,YACL,4BAA4B;;CAwCtC,CAAC;AAEF,eAAO,MAAM,aAAa,cAAqC,GAAG,YAEjE,CAAC","file":"flatTool.d.ts","sourcesContent":["/** ****************************************************************\n MIT License https://github.com/qiu8310/minapp/blob/v1.0.0-alpha.1/packages/minapp-core/src/system/util/object.ts\n Author Mora <qiuzhongleiabc@126.com> (https://github.com/qiu8310)\n****************************************************************** */\n\nexport const getPrototypeOf = function (obj: any): any {\n  return Object.getPrototypeOf ? Object.getPrototypeOf(obj) : obj.__proto__;\n};\n\n/**\n * 判断 something 是不是一个 JS Object (从 mora-script 中取过来的)\n *\n * 除了 null, 及字面量，其它一般都是 Object，包括 函数\n */\nexport const isObject = function isObject(something: any) {\n  const type = typeof something;\n  return something !== null && (type === 'function' || type === 'object');\n};\n\n/**\n * 遍历继承关系类的 prototype\n *\n * @export\n * @param {Function} callback - 回调函数，函数参数是遍历的每个实例的 prototype，函数如果返回 false，会终止遍历\n * @param {any} fromCtor  - 要遍历的起始 class 或 prototype\n * @param {any} toCtor    - 要遍历的结束 class 或 prototype\n * @param {boolean} [includeToCtor=true] - 是否要包含结束 toCtor 本身\n *\n * @example\n * A -> B -> C\n *\n * 在 C 中调用： iterateInheritedPrototype(fn, A, C, true)\n * 则，fn 会被调用三次，分别是 fn(A.prototype) fn(B.prototype) fn(C.prototype)\n */\nexport const iterateInheritedPrototype = function iterateInheritedPrototype(\n  callback: (proto: Record<string, any>) => boolean | void,\n  fromCtor: any,\n  toCtor: any,\n  includeToCtor = true,\n) {\n  let proto = fromCtor.prototype || fromCtor;\n  const toProto = toCtor.prototype || toCtor;\n\n  while (proto) {\n    if (!includeToCtor && proto === toProto) break;\n    if (callback(proto) === false) break;\n    if (proto === toProto) break;\n    proto = getPrototypeOf(proto);\n  }\n};\n\nexport interface ClassInstanceToObjectOptions {\n  /**\n   * 将所有的对象中的函数绑定到指定的对象上\n   *\n   * **注意：对象中的箭头函数无法重新绑定**\n   */\n  bindTo?: any;\n\n  /**\n   * 要排除的键名\n   *\n   * 默认： ['constructor']\n   */\n  excludes?: string[];\n\n  /**\n   * 递归遍历到的终点对象或class(不会遍历终点对象上的属性)\n   *\n   * 默认： Object\n   */\n  till?: any;\n\n  /**\n   * 生成的新对象的键值是否需要 enumerable， 0 表示使用原本的配置，此值默认为 true\n   */\n  enumerable?: 0 | boolean;\n  /**\n   * 生成的新对象的键值是否需要 configurable， 不指定或指定 0 则使用原本的\n   */\n  configurable?: 0 | boolean;\n  /**\n   * 生成的新对象的键值是否需要 writable，不指定或指定 0 则使用原本的\n   */\n  writable?: 0 | boolean;\n}\n\n/**\n *\n * 将一个可能包含原型链的对象扁平化成单个对象\n *\n * 如，现有这样的类的继承关系 A -> B -> C，当创建一个实例 a = new A() 时\n *\n * a 实例会存有 B、C 的原型链，使用此函数 newa = toObject(a) 之后，\n * newa 就会变成一个 PlainObject，但它有 A、B、C 上的所有属性和方法，\n * 当然不包括静态属性或方法\n *\n * 注意1：用此方法的话，尽量避免在类中使用胖函数，胖函数的 this 死死的绑定\n * 在原对象中，无法重新绑定\n *\n * 注意2：类继承的时候不要在函数中调用 super，toObject 之后是扁平的，没有 super 之说\n */\nexport const toObject = function toObject(\n  something: any,\n  options: ClassInstanceToObjectOptions = {},\n): { [key: string]: any } {\n  const obj = {};\n  if (!isObject(something)) return obj;\n\n  const excludes = options.excludes || ['constructor'];\n  const { enumerable = true, configurable = 0, writable = 0 } = options;\n  const defaultDesc: PropertyDescriptor = {};\n  if (enumerable !== 0) defaultDesc.enumerable = enumerable;\n  if (configurable !== 0) defaultDesc.configurable = configurable;\n  if (writable !== 0) defaultDesc.writable = writable;\n\n  iterateInheritedPrototype(\n    (proto) => {\n      Object.getOwnPropertyNames(proto).forEach((key) => {\n        if (excludes.indexOf(key) >= 0) return;\n        if (Object.prototype.hasOwnProperty.call(obj, key)) return;\n        const desc = Object.getOwnPropertyDescriptor(proto, key) as PropertyDescriptor;\n\n        const fnKeys = ['get', 'set', 'value'] as 'get'[];\n        fnKeys.forEach((k) => {\n          if (typeof desc[k] === 'function') {\n            const oldFn = desc[k] as any;\n            desc[k] = function (...args: any[]) {\n              return oldFn.apply(\n                Object.prototype.hasOwnProperty.call(options, 'bindTo') ? options.bindTo : this,\n                args,\n              );\n            };\n          }\n        });\n        Object.defineProperty(obj, key, { ...desc, ...defaultDesc });\n      });\n    },\n    something,\n    options.till || Object,\n    false,\n  );\n\n  return obj;\n};\n\nexport const isPlainObject = function isPlainObject(something: any) {\n  return Object.prototype.toString.call(something) === '[object Object]';\n};\n"]}