{"version":3,"sources":["../src/sticky/sticky.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,cAAc,EAAe,MAAM,qBAAqB,CAAC;AASlE,aAAK,YAAY,GAAG,MAAM,iBAAiB,CAAC,QAAQ,CAAC;AAErD,UAAU,WAAW;IACnB,MAAM,EAAE,MAAM,CAAC;IACf,QAAQ,EAAE,OAAO,CAAC;IAClB,SAAS,EAAE,YAAY,CAAC;IACxB,SAAS,EAAE,MAAM,CAAC;CACnB;AAGD,MAAM,CAAC,OAAO,OAAO,MAAO,SAAQ,cAAc;IAChD,eAAe,WAAuB;IAEtC,UAAU,EAAE,WAAW,CAAgB;IAEvC,SAAS,WAIP;IAEF,SAAS;mDAcQ;YAAE,SAAS,EAAE,MAAM,CAAA;SAAE;MAZpC;IAEF,IAAI;;;;MAIF;IAEF,OAAO;IAIP,QAAQ,CAAC,KAAK,CAAC,EAAE;QAAE,SAAS,EAAE,MAAM,CAAA;KAAE;IA+CtC,gBAAgB,CAAC,IAAI,EAAE;QAAE,OAAO,EAAE,OAAO,CAAC;QAAC,MAAM,CAAC,EAAE,MAAM,CAAC;QAAC,SAAS,CAAC,EAAE,MAAM,CAAA;KAAE;IA4BhF,gBAAgB;CAMjB","file":"sticky.d.ts","sourcesContent":["import { SuperComponent, wxComponent } from '../common/src/index';\nimport props from './props';\nimport config from '../common/config';\n\nimport { pageScrollMixin, getRect } from './utils';\n\nconst { prefix } = config;\n\nconst ContainerClass = `.${prefix}-sticky`;\ntype ContainerRef = () => WechatMiniprogram.NodesRef;\n\ninterface StickyProps {\n  zIndex: number;\n  disabled: boolean;\n  container: ContainerRef;\n  offsetTop: number;\n}\n\n@wxComponent()\nexport default class Sticky extends SuperComponent {\n  externalClasses = [`${prefix}-class`];\n\n  properties: StickyProps = props as any;\n\n  behaviors = [\n    pageScrollMixin(function (event) {\n      this.onScroll(event);\n    }),\n  ];\n\n  observers = {\n    'offsetTop, disabled, container': this.onScroll,\n  };\n\n  data = {\n    containerStyle: '',\n    contentStyle: '',\n    classPrefix: `.${prefix}-sticky`,\n  };\n\n  mounted() {\n    this.onScroll();\n  }\n\n  onScroll(event?: { scrollTop: number }) {\n    const { scrollTop } = event || {};\n    const { container, offsetTop, disabled } = this.properties;\n\n    if (disabled) {\n      this.setDataAfterDiff({\n        isFixed: false,\n        transform: 0,\n      });\n      return;\n    }\n\n    this.scrollTop = scrollTop || this.scrollTop;\n\n    if (typeof container === 'function') {\n      Promise.all([getRect(this, ContainerClass), this.getContainerRect()]).then(\n        ([root, container]) => {\n          if (offsetTop + root.height > container.height + container.top) {\n            this.setDataAfterDiff({\n              isFixed: false,\n              transform: container.height - root.height,\n            });\n          } else if (offsetTop >= root.top) {\n            this.setDataAfterDiff({\n              isFixed: true,\n              height: root.height,\n              transform: 0,\n            });\n          } else {\n            this.setDataAfterDiff({ isFixed: false, transform: 0 });\n          }\n        },\n      );\n\n      return;\n    }\n\n    getRect(this, ContainerClass).then((root) => {\n      if (offsetTop >= root.top) {\n        this.setDataAfterDiff({ isFixed: true, height: root.height });\n        this.transform = 0;\n      } else {\n        this.setDataAfterDiff({ isFixed: false });\n      }\n    });\n  }\n\n  setDataAfterDiff(data: { isFixed: boolean; height?: number; transform?: number }) {\n    const { offsetTop } = this.properties;\n    const { containerStyle: prevContainerStyle, contentStyle: prevContentStyle } = this.data;\n    const { isFixed, height, transform } = data;\n    wx.nextTick(() => {\n      let containerStyle = '';\n      let contentStyle = '';\n\n      if (isFixed) {\n        containerStyle += `height:${height}px;`;\n        contentStyle += `position:fixed;top:${offsetTop}px`;\n      }\n      if (transform) {\n        const translate = `translate3d(0, ${transform}px, 0)`;\n        contentStyle += `-webkit-transform:${translate};transform:${translate};`;\n      }\n\n      if (prevContainerStyle !== containerStyle || prevContentStyle !== contentStyle) {\n        this.setData({ containerStyle, contentStyle });\n      }\n\n      this.triggerEvent('scroll', {\n        scrollTop: this.scrollTop,\n        isFixed,\n      });\n    });\n  }\n\n  getContainerRect() {\n    const nodesRef: WechatMiniprogram.NodesRef = this.properties.container();\n    return new Promise<WechatMiniprogram.BoundingClientRectCallbackResult>((resolve) =>\n      nodesRef.boundingClientRect(resolve).exec(),\n    );\n  }\n}\n"]}