{"version":3,"sources":["../src/message/message.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,cAAc,EAAe,MAAM,qBAAqB,CAAC;AAElE,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AASnD,MAAM,CAAC,OAAO,OAAO,OAAQ,SAAQ,cAAc;IACjD,eAAe,WAMb;IAEF,OAAO;;;MAGL;IAGF,UAAU,EAAE,YAAY,CAA2C;IAGnE,IAAI;;;;;;;;;MASF;IAEF,SAAS;;MAYP;IAEF,aAAa;IACb,mBAAmB,SAAK;IAExB,WAAW;IACX,oBAAoB,SAAK;IAEzB,cAAc,8BAGX;IAGH,aAAa,0CAKD;IAGZ,aAAa,0CAKD;IAEZ,KAAK;IAKL,gBAAgB;IAChB,cAAc;IAOd,SAAS,CAAC,EAAE,EAAE,MAAM,IAAI;IAIxB,QAAQ;IAIR,eAAe;IACf,OAAO,CAAC,IAAI,mBAAuB;IA6BnC,uBAAuB;IACvB,cAAc;IAsDd,aAAa;IACb,UAAU,CAAC,SAAS,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAW9C,aAAa;IACb,WAAW,CAAC,SAAS,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAW/C,aAAa;IACb,qBAAqB;IAKrB,IAAI;IAmBJ,IAAI;IASJ,KAAK;IAQL,WAAW;IAKX,cAAc;CAGf","file":"message.d.ts","sourcesContent":["import { SuperComponent, wxComponent } from '../common/src/index';\nimport config from '../common/config';\nimport { MessageProps } from './message.interface';\nimport props from './props';\n\nconst { prefix } = config;\nconst name = `${prefix}-message`;\n\n// 展示动画持续时间\nconst SHOW_DURATION = 500;\n@wxComponent()\nexport default class Message extends SuperComponent {\n  externalClasses = [\n    't-class',\n    't-class-content',\n    't-class-icon',\n    't-class-action',\n    't-class-close-btn',\n  ];\n\n  options = {\n    styleIsolation: 'apply-shared' as const,\n    multipleSlots: true,\n  };\n\n  // 组件的对外属性\n  properties: MessageProps = { ...props } as unknown as MessageProps;\n\n  // 组件的内部数据\n  data = {\n    prefix,\n    classPrefix: name,\n    visible: false,\n    loop: -1,\n    animation: [],\n    showAnimation: [],\n    iconName: '',\n    wrapTop: -92,\n  };\n\n  observers = {\n    marquee(val) {\n      if (JSON.stringify(val) === '{}') {\n        this.setData({\n          marquee: {\n            speed: 50,\n            loop: -1,\n            delay: 5000,\n          },\n        });\n      }\n    },\n  };\n\n  /** 延时关闭句柄 */\n  closeTimeoutContext = 0;\n\n  /** 动画句柄 */\n  nextAnimationContext = 0;\n\n  resetAnimation = wx.createAnimation({\n    duration: 0,\n    timingFunction: 'linear',\n  });\n\n  // 入场动画\n  showAnimation = wx\n    .createAnimation({ duration: SHOW_DURATION, timingFunction: 'ease' })\n    .translateY(0)\n    .opacity(1)\n    .step()\n    .export();\n\n  // 出场动画\n  hideAnimation = wx\n    .createAnimation({ duration: SHOW_DURATION, timingFunction: 'ease' })\n    .translateY(this.data.wrapTop)\n    .opacity(0)\n    .step()\n    .export();\n\n  ready() {\n    this.memoInitalData();\n    this.setIcon();\n  }\n\n  /** 记录组件设置的项目 */\n  memoInitalData() {\n    this.initalData = {\n      ...this.properties,\n      ...this.data,\n    };\n  }\n\n  resetData(cb: () => void) {\n    this.setData({ ...this.initalData }, cb);\n  }\n\n  detached() {\n    this.clearMessageAnimation();\n  }\n\n  /** icon 值设置 */\n  setIcon(icon = this.properties.icon) {\n    // 使用空值\n    if (!icon) {\n      this.setData({ iconName: '' });\n      return;\n    }\n    // 固定值\n    if (typeof icon === 'string') {\n      this.setData({\n        iconName: `${icon}`,\n      });\n      return;\n    }\n\n    // 使用默认值\n    if (icon) {\n      let nextValue = 'notification';\n      const { theme } = this.properties;\n      const themeMessage = {\n        info: 'error-circle',\n        success: 'check-circle',\n        warning: 'error-circle',\n        error: 'error-circle',\n      };\n      nextValue = themeMessage[theme];\n      this.setData({ iconName: nextValue });\n    }\n  }\n\n  /** 检查是否需要开启一个新的动画循环 */\n  checkAnimation() {\n    const speeding = this.properties.marquee.speed;\n\n    if (!this.properties.marquee) {\n      return;\n    }\n\n    if (this.data.loop > 0) {\n      this.data.loop -= 1;\n    } else if (this.data.loop === 0) {\n      // 动画回到初始位置\n      this.setData({ animation: this.resetAnimation.translateX(0).step().export() });\n      return;\n    }\n\n    if (this.nextAnimationContext) {\n      this.clearMessageAnimation();\n    }\n\n    const warpID = `#${name}__text-wrap`;\n    const nodeID = `#${name}__text`;\n    Promise.all([this.queryWidth(nodeID), this.queryWidth(warpID)]).then(\n      ([nodeWidth, warpWidth]) => {\n        this.setData(\n          {\n            animation: this.resetAnimation.translateX(warpWidth).step().export(),\n          },\n          () => {\n            const durationTime = ((nodeWidth + warpWidth) / speeding) * 1000;\n            const nextAnimation = wx\n              .createAnimation({\n                // 默认50px/s\n                duration: durationTime,\n              })\n              .translateX(-nodeWidth)\n              .step()\n              .export();\n\n            // 这里就只能用 setTimeout/20, nextTick 没用\n            // 不用这个的话会出现reset动画没跑完就开始跑这个等的奇怪问题\n            setTimeout(() => {\n              this.nextAnimationContext = setTimeout(\n                this.checkAnimation.bind(this),\n                durationTime,\n              ) as unknown as number;\n\n              this.setData({ animation: nextAnimation });\n            }, 20);\n          },\n        );\n      },\n    );\n  }\n\n  /** 获取元素宽度 */\n  queryWidth(queryName: string): Promise<number> {\n    return new Promise((resolve) => {\n      this.createSelectorQuery()\n        .select(queryName)\n        .boundingClientRect(({ width }) => {\n          resolve(width);\n        })\n        .exec();\n    });\n  }\n\n  /** 获取元素长度 */\n  queryHeight(queryName: string): Promise<number> {\n    return new Promise((resolve) => {\n      this.createSelectorQuery()\n        .select(queryName)\n        .boundingClientRect(({ height }) => {\n          resolve(height);\n        })\n        .exec();\n    });\n  }\n\n  /** 清理动画循环 */\n  clearMessageAnimation() {\n    clearTimeout(this.nextAnimationContext);\n    this.nextAnimationContext = 0;\n  }\n\n  show() {\n    const { duration, icon } = this.properties;\n    this.setData({ visible: true, loop: this.properties.marquee.loop });\n    this.reset();\n    this.setIcon(icon);\n    this.checkAnimation();\n    if (duration && duration > 0) {\n      this.closeTimeoutContext = setTimeout(() => {\n        this.hide();\n        this.triggerEvent('durationEnd', { self: this });\n      }, duration) as unknown as number;\n    }\n\n    const wrapID = `#${name}`;\n    this.queryHeight(wrapID).then((wrapHeight) => {\n      this.setData({ showAnimation: this.showAnimation, wrapTop: -wrapHeight });\n    });\n  }\n\n  hide() {\n    this.reset();\n    this.setData({ showAnimation: this.hideAnimation });\n    setTimeout(() => {\n      this.setData({ visible: false, animation: [] });\n    }, SHOW_DURATION);\n  }\n\n  // 重置定时器\n  reset() {\n    if (this.nextAnimationContext) {\n      this.clearMessageAnimation();\n    }\n    clearTimeout(this.closeTimeoutContext);\n    this.closeTimeoutContext = 0;\n  }\n\n  handleClose() {\n    this.hide();\n    this.triggerEvent('closeBtnClick');\n  }\n\n  handleBtnClick() {\n    this.triggerEvent('actionBtnClick', { self: this });\n  }\n}\n"]}