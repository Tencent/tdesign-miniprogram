{"version":3,"sources":["../src/avatar/avatar-group.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAe,MAAM,qBAAqB,CAAC;AAQlE,MAAM,CAAC,OAAO,OAAO,WAAY,SAAQ,cAAc;IACrD,eAAe,WAAuB;IAEtC,UAAU,sCAAoB;IAE9B,IAAI;;;;;MAKF;IAEF,OAAO;;MAEL;IAEF,SAAS;;;yBAGQ,WAAW;;MAI1B;IAEF,KAAK;IAUL,OAAO;QACL;;;;WAIG;;QAMH;;;;;;WAMG;;QAWH;;;;;;;WAOG;;QAaH;;;;WAIG;;QAQH;;;;WAIG;;MASH;CACH","file":"avatar-group.d.ts","sourcesContent":["import { SuperComponent, wxComponent } from '../common/src/index';\nimport config from '../common/config';\nimport avatarGroupProps from './avatar-group-props';\n\nconst { prefix } = config;\nconst name = `${prefix}-avatar-group`;\n\n@wxComponent()\nexport default class AvatarGroup extends SuperComponent {\n  externalClasses = [`${prefix}-class`];\n\n  properties = avatarGroupProps;\n\n  data = {\n    prefix,\n    classPrefix: name,\n    hasChild: true,\n    length: 0,\n  };\n\n  options = {\n    multipleSlots: true,\n  };\n\n  relations = {\n    './avatar': {\n      type: 'descendant' as 'descendant',\n      linked(this: AvatarGroup) {\n        this.children = this.getRelationNodes('./avatar');\n      },\n    },\n  };\n\n  ready() {\n    this.setData({\n      length: this.children.length,\n    });\n    this.handleHasChild(this.children, this.data.hasChild);\n    this.handleChildSlot(this.properties.max, this.children, this.handleChildMax);\n    this.handleChildSize(this.properties.size, this.children);\n    this.handleChildCascading(this.properties.cascading, this.children);\n  }\n\n  methods = {\n    /**\n     * @param children avatar-group的所有avatar子节点\n     * @param hasChild 是否为子节点（slot插槽以及默认的avatar折叠元素没有parent）\n     * @description\n     */\n    handleHasChild(children, hasChild) {\n      children.forEach((child) => {\n        child.updateIsChild(hasChild);\n      });\n    },\n    /**\n     *\n     * @param max 最大avatar数量\n     * @param children avatar-group的所有avatar子节点\n     * @param f handleChildMax函数\n     * @description 判断是否传入自定义折叠元素\n     */\n    handleChildSlot(max, children, f) {\n      const query = this.createSelectorQuery();\n      const slotName = `.${this.data.classPrefix}__collapse--slot`;\n      query.select(slotName).boundingClientRect();\n      query.exec((res) => {\n        const isSlot = !!res[0].width;\n        f(max, children, isSlot);\n      });\n    },\n\n    /**\n     *\n     * @param max 最大avatar数量\n     * @param children avatar-group的所有avatar子节点\n     * @param isSlotElement 是否传入自定义折叠元素（res[0].width不为空表示传入）\n     * @description avatar-group的最大数量处理\n     *              + 如果未传入自定义折叠元素，当超出max数量时，显示默认折叠元素\n     */\n    handleChildMax(max, children, isSlotElement) {\n      const len = children.length;\n      if (!max || max > len) return;\n\n      const slotElement = isSlotElement ? children.pop() : '';\n      const leftChildren = children.splice(max, len - max, isSlotElement && slotElement);\n\n      leftChildren.forEach((child) => {\n        child.updateShow();\n      });\n    },\n\n    /**\n     * @param size 尺寸，优先级低于avatar自身设置的size\n     * @param children avatar-group的所有avatar子节点\n     * @description 更新avatar节点的size属性\n     */\n    handleChildSize(size, children) {\n      if (!size) return;\n      children.forEach((child) => {\n        child.updateSize(size);\n      });\n    },\n\n    /**\n     * @param cascading 层叠关系\n     * @param children avatar-group的所有avatar子节点\n     * @description 右侧图片在上可用css直接实现，左侧图片在上，通过设置z-index实现\n     */\n    handleChildCascading(cascading, children) {\n      if (cascading === 'right-up') return;\n\n      const defaultZIndex = 100;\n      children.forEach((child, index) => {\n        child.updateCascading(defaultZIndex - index * 10);\n      });\n    },\n  };\n}\n"]}